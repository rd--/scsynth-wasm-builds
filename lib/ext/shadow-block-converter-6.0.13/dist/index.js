!function(e,t){if("object"==typeof exports&&"object"==typeof module)module.exports=t(require("blockly/core"));else if("function"==typeof define&&define.amd)define(["blockly/core"],t);else{var n="object"==typeof exports?t(require("blockly/core")):t(e.Blockly);for(var o in n)("object"==typeof exports?exports:e)[o]=n[o]}}(this,(e=>(()=>{"use strict";var t={370:t=>{t.exports=e}},n={};function o(e){var r=n[e];if(void 0!==r)return r.exports;var i=n[e]={exports:{}};return t[e](i,i.exports,o),i.exports}o.d=(e,t)=>{for(var n in t)o.o(t,n)&&!o.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},o.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),o.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var r={};o.r(r),o.d(r,{BlockShadowStateChange:()=>s,shadowBlockConversionChangeListener:()=>a});var i=o(370);class s extends i.Events.BlockBase{constructor(e,t,n){super(e),this.type=s.EVENT_TYPE,this.inputIndexInParent=t,this.shadowState=n}toJson(){const e=super.toJson();return e.inputIndexInParent=this.inputIndexInParent,e.shadowState=this.shadowState,e}static fromJson(e,t,n){const o=super.fromJson(e,t,n);return o.inputIndexInParent=e.inputIndexInParent,o.shadowState=e.shadowState,n}isNull(){return!1}run(e){const t=this.getEventWorkspace_();if(!this.blockId)throw new Error("The block ID is undefined. Either pass a block to the constructor, or call fromJson");const n=t.getBlockById(this.blockId);if(!n)throw new Error("The associated block is undefined. Either pass a block to the constructor, or call fromJson");const o=n.getConnections_(!0);let r;if(null===this.inputIndexInParent)r=n.nextConnection;else{if("number"!=typeof this.inputIndexInParent||this.inputIndexInParent<0||this.inputIndexInParent>=o.length)throw new Error("inputIndexInParent was invalid.");r=n.inputList[this.inputIndexInParent].connection}if(null===r)throw new Error("No matching connection was found.");e&&r.setShadowState(this.shadowState||null)}}function c(e){var t,n;let o=null,r=!1;if((null===(t=e.previousConnection)||void 0===t?void 0:t.isConnected())?o=e.previousConnection.targetConnection:(null===(n=e.outputConnection)||void 0===n?void 0:n.isConnected())&&(o=e.outputConnection.targetConnection,r=!0),null===o)return e;let a=o.getSourceBlock();const l=o.getParentInput(),u=l?a.inputList.indexOf(l):null,d=o.getShadowState(!1),p=i.serialization.blocks.save(e,{addCoordinates:!1,addInputBlocks:!0,addNextBlocks:!0,doFullSerialization:!1});if(null===d||null===p)return e;if(a.isShadow()){const e=c(a);if(null===e)throw new Error("No parent block was created, so we can't recreate the current block either.");if(a=e,null===u)o=a.nextConnection;else{if(u<0||u>=a.inputList.length)throw new Error("inputIndexInParent is invalid.");o=a.inputList[u].connection}if(null===o)throw new Error("Couldn't find the corresponding connection on the new version of the parent block.")}p.id=void 0;const h=i.serialization.blocks.append(p,a.workspace,{recordUndo:!0}),f=r?h.outputConnection:h.previousConnection;f&&o.connect(f);const w=i.common.getSelected()===e;return o.setShadowState(d),i.Events.fire(new s(a,u,d)),w&&i.common.setSelected(h),h}function a(e){if(!e.recordUndo)return;if(e.type!=i.Events.BLOCK_CHANGE)return;const t=e;if(!t.workspaceId||!t.blockId)return;const n=i.Workspace.getById(t.workspaceId);if(!n)return;const o=n.getBlockById(t.blockId);if(!o)return;if(!o.isShadow())return;const r=i.Events.getGroup();t.group?i.Events.setGroup(t.group):i.Events.setGroup(!0),c(o),i.Events.setGroup(r)}return s.EVENT_TYPE="block_shadow_state_change",i.registry.register(i.registry.Type.EVENT,s.EVENT_TYPE,s),r})()));

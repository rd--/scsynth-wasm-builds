/*! For license information please see index.js.LICENSE.txt */
!function(e,t){if("object"==typeof exports&&"object"==typeof module)module.exports=t(require("blockly/core"));else if("function"==typeof define&&define.amd)define(["blockly/core"],t);else{var n="object"==typeof exports?t(require("blockly/core")):t(e.Blockly);for(var o in n)("object"==typeof exports?exports:e)[o]=n[o]}}(this,e=>(()=>{"use strict";var t={370:t=>{t.exports=e}},n={};function o(e){var r=n[e];if(void 0!==r)return r.exports;var i=n[e]={exports:{}};return t[e](i,i.exports,o),i.exports}o.d=(e,t)=>{for(var n in t)o.o(t,n)&&!o.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},o.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),o.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var r={};o.r(r),o.d(r,{BlockShadowStateChange:()=>s,shadowBlockConversionChangeListener:()=>a});var i=o(370);class s extends i.Events.BlockBase{constructor(e,t,n){super(e),this.type=s.EVENT_TYPE,this.inputIndexInParent=t,this.shadowState=n}toJson(){const e=super.toJson();return e.inputIndexInParent=this.inputIndexInParent,e.shadowState=this.shadowState,e}static fromJson(e,t,n){const o=super.fromJson(e,t,n);return o.inputIndexInParent=e.inputIndexInParent,o.shadowState=e.shadowState,n}isNull(){return!1}run(e){const t=this.getEventWorkspace_();if(!this.blockId)throw new Error("The block ID is undefined. Either pass a block to the constructor, or call fromJson");const n=t.getBlockById(this.blockId);if(!n)throw new Error("The associated block is undefined. Either pass a block to the constructor, or call fromJson");const o=n.getConnections_(!0);let r;if(null===this.inputIndexInParent)r=n.nextConnection;else{if("number"!=typeof this.inputIndexInParent||this.inputIndexInParent<0||this.inputIndexInParent>=o.length)throw new Error("inputIndexInParent was invalid.");r=n.inputList[this.inputIndexInParent].connection}if(null===r)throw new Error("No matching connection was found.");e&&r.setShadowState(this.shadowState||null),i.getFocusManager().focusNode(n)}}function c(e,t=!1){var n,o;let r=null,a=!1;if((null===(n=e.previousConnection)||void 0===n?void 0:n.isConnected())?r=e.previousConnection.targetConnection:(null===(o=e.outputConnection)||void 0===o?void 0:o.isConnected())&&(r=e.outputConnection.targetConnection,a=!0),null===r)return e;let u=r.getSourceBlock();const l=r.getParentInput(),d=l?u.inputList.indexOf(l):null,p=r.getShadowState(!1),f=i.serialization.blocks.save(e,{addCoordinates:!1,addInputBlocks:!0,addNextBlocks:!0,doFullSerialization:!1});if(null===p||null===f)return e;if(u.isShadow()){const e=c(u);if(null===e)throw new Error("No parent block was created, so we can't recreate the current block either.");if(u=e,null===d)r=u.nextConnection;else{if(d<0||d>=u.inputList.length)throw new Error("inputIndexInParent is invalid.");r=u.inputList[d].connection}if(null===r)throw new Error("Couldn't find the corresponding connection on the new version of the parent block.")}f.id=void 0;const h=i.serialization.blocks.append(f,u.workspace,{recordUndo:!0}),w=a?h.outputConnection:h.previousConnection;return w&&r.connect(w),r.setShadowState(p),i.Events.fire(new s(u,d,p)),t&&i.getFocusManager().focusNode(h),h}function a(e){if(!e.recordUndo)return;if(e.type!=i.Events.BLOCK_CHANGE)return;const t=e;if(!t.workspaceId||!t.blockId)return;const n=i.Workspace.getById(t.workspaceId);if(!n)return;const o=n.getBlockById(t.blockId);if(!o)return;if(!o.isShadow())return;const r=i.Events.getGroup();t.group?i.Events.setGroup(t.group):i.Events.setGroup(!0),c(o,!0),i.Events.setGroup(r)}return s.EVENT_TYPE="block_shadow_state_change",i.registry.register(i.registry.Type.EVENT,s.EVENT_TYPE,s),r})());
//# sourceMappingURL=index.js.map